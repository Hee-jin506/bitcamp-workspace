package com.eomcs.oop.ex03;

public class Exam0130 {
  static class A {
    static int v1;
    static boolean v2;
  }
  
  public static void main(String[] args) {
    A.v1 = 100;
    A.v2 = true;
    
    System.out.printf("%d, %b\n", A.v1, A.v2);
    // 클래스를 사용하는 순간 클래스가 로딩되고, 스태틱 변수는 자동 생성된다.
    
  }

}

// 클래스 로딩
// - 외부 저장장치에 있는 .class 파일을
// JVM이 관리하는 메모리로 로딩하는 것.
// 클래스의 코드를 사용하는 시점에 메모리에 로딩된다.

// 클래스의 코드를 사용하는 시점?
// 1) 스태틱 멤버를 사용할 때
// 2) new 명령을 사용하여 인스턴스를 생성할 때
// 한번 로딩되면 JVM을 종료할 떄까지 유지한다.
// 물론 강제로 unloading 할 수 있다. 다시 로딩도 할 수 있다.

// 클래스를 로딩할 거라도 착각하는 경우
// 다음과 같이 레퍼런스 변수를 선언할 때는 로딩하지 않는다.

// 클래스 로딩 과정
// 1) 클래스 파일을 찾는다.
// - JDK가 설치된 폴더의 하위 폴더인 /lib에서 찾는다.
// - OS의 CLASSPATH 환경변수에 설정된 디렉토리를 탐색하여 찾는다.
// - JVM을 실행할 때 -classpath 또는 -cp 옵션으로 설정된 디렉토리를 탐색하여 찾는다.
// - JVM을 실행하는 현재 폴더에서 찾는다.
// - 그래도 없으면 오류를 띄운다.
// 2) 바이트 코드 검증
// - 클래스의 바이트 코드 유효성을 검사한다.
// 3) 클래스를 Method Area 영역에 로딩한다.
// - 즉 클래스를 외부 저장소(HDD)에서 내부 저장소(RAM)로 로딩한다.
// - bytecode를 분석하여 코드(생성자, 메서드)와 상수를 따로 보관한다.
// 4) 스태틱 필드 및 메서드 테이블 준비
// - method Area에 스태틱 필드 생성
// - 클래스 내부에서 사용하는 이름(변수명, 메서드명, 클래스명) 목록을 준비한다.
// 5) 참조하는 외부 클래스나 인터페이스 검사(Resolve)
// - 다른 클래스나 인터페이스를 참조하는 것이 유효한지 검사한다.
// 6) 클래스 초기화
// - 변수 초기화 문장, 스태틱 블록을 실행한다.
// 7) main() 메서드를 호출한다.
// - 클래스를 실행하는 것이라면 main() 메서드를 찾아 실행한다.
