package com.eomcs.basic.ex04;

public class Exam0510 {
  public static void main(String[] args) {
    int[] p = new int[3]; // (int*)malloc(sizeof(int) * 3) int 연속 메모리 3개 만들어라.
    // int 배열의 주소를 담을 p
    // 자바에서는 주소를 담는 변수를 레퍼런스라고 부른다.
    // 
    // new int[3]
    // int 변수를 연속해서 3개 확보한다.
    // 메모리를 확보한 후 리턴 값은 그 메모리의 시작 주소이다.
    // 
    
    // 배열의 개수 알아내기 
    System.out.println(p.length);
    
    // 배열의 주소가 없는 상태에서 사용하지 말라!
    // int[] x;
    // x = null;
    // System.out.println(x.length);
    
    // 배열에 값 저장
    p[0] = 100;
    p[1] = 200;
    p[2] = 300;
    
    System.out.printf("%d,%d,%d\n", p[0], p[1], p[2]);
    // 자바에서는 주소를 마음대로 연산 불가
    
    // p[3] = 400; // 실행 예외 (범위를 벗어난 인덱스) (runtime exception)
    // p[-1] = 500; // 실행 예외 (범위를 벗어난 인덱스) (runtime exception)
    
    int sum = 0;
    for (int i =0; i < p.length; i++) {
      sum = sum + p[i];
    }
    System.out.println(sum);

    
    // 배열 레퍼런스를 선언하는 방법 
    int[] p2; // 자바에서 주로 사용하는 방식
    int p3[]; // C 언어 방식도 사용가능
    // 단 개수를 지정해서는 안된다.
    
    //  p2 = 100; // 컴파일 에
    p2 = p; // p레퍼런스에 저장된 주소를 p2 레퍼런스로 복사한다.
    
    p2[1] = 1000;
    System.out.println(p[1]);
    
    p = new int[4];
    p[1] = 2000;
    System.out.printf("%d,%d\n", p[1], p2[1]);
    
    // System.out.println(p3[1]); // 존재하지 않는 것은 쓸 수 없다. 컴파일 오류
    
    // System.println(p); // 주소 값을 출력 불가
    
    // 레퍼런스 변수의 주소값을 0으로 초기화하기
    // p2 = 0; // 이렇게 직접적으로 초기화시킬 수 없다.
    p2 = null; // 주소변수(레퍼런스)를 0으로 초기화시키려면 null 사용하라.
    
    // System.out.println(p2[0]); // 아무런 주소 안찍어놓고 출력하라그러면
    // NUllPointerException 이라는 에러가 뜸
    //System.out.println(p2[0]);
    
    int k1;
    // System.out.println(k1); // 초기화없이 사용하면 컴파일 오류
    
    int[] k2 = new int[3];
    // new 명령으로 메모리를 준비할 때****,
    // 모든 메모리는 0으로 자동 초기화 된다.
    // 따라서 따로 초기화할 필요 없이 바로 사용할 수 있다.
    System.out.println(k2[0]);
    System.out.println(k2[1]);
    System.out.println(k2[2]);
    
    // new int[3]; 이라고 하면 세개의 int메모리가 생기고 동시에 0이 들어간다.
    
    // 배열 생성 후 즉시 초기화하기
    int[] k3  = new int[] {100,200,300};
    // =>{} 안에 값을 넣을 수 있는 int 배열을 만든 후 그 배열에 값을 넣는다.
    // => 배열의 개수를 지정해서는 안된다.
    // int[] k3 = new int[3] {100,200,300};
    
    int[] k4;
    k4 = new int[] {10,20};
    
    int[] k5 = {11,12,13};
    // 앞에 new int[] 생략 가능
    // 컴파일 하기전에 바로 new int[]가 붙으므로 결국 같은 명령
    
    int[] k6;
    // k6 = {111,222,333}; // 컴파일 오류 변수선언 없이 생략 할 수 없다.
    
    int[] x1 = new int[3];
    int[] x2 = new int[4];
    int[] x3 = x1;
    // 그럼 JVM 이 인스턴스를 가리키는 레퍼런스의 개수를 카운트한다.
    // 레퍼런스 카운트를 JVM이 관리한다.
    x2 = x1;
    // x2가 가리키던 int[4] 배열 메모리의 주소를 잃어버려
    // 더이상 사용할 수 없다.
    // 주소를 잃어버려 사용할 수 없는 메모리 = 쓰레기(garbage)
    // 가비지는 JVM이 자동으로 해제시킨다.
    // 단 바로 해제하지 ㅇ낳고 다음 조건에 해당할때 해제
    // 1) 메모리가 부족할 때
    // 2) 시스템이 한참동안 한가할 때
    // => 결론! 언제 가비지를 메모리에서 해제시킬지 알 수 없다.
    // c는 주소를 잃어버리는 순간 바로 버리지만 
    // 자바는 천천히 버린다.
    // 메모리를 직접 해제시키는 언어가 c, c++이 있다.
    // c#, java, 파이썬 현대적인 언어들은 개발자들이 메모리를 통제하는 것을 막는다.
    // 지금 트렌드는 메모리를 직접 통제 안하고 버추얼 머신에게 맡김
    // 바로바로 메모리가 안지워지기 때문에 메모리를 100프로 완전히 효율적으로 사용할 수 없지만
    // 그래도 된다. 메모리가 가격이 싸지고 풍부해졌기 때문
    // 메모리 아까워할 필요가 없다
    // 초보는 메모리를 신경쓰지마라. 메모리가 아까워서 바들바들 떨필요 없고
    // 기능이나 먼저 구현해라
    // JVM에서 가비지 컬렉터는 가비지를 찾아 해제시킴.
    
    // 가비지를 강제로 동작시킬 수 있는 방법
    System.gc(); // 가능하다면 빠른 시일내에 가비지를 수집해질 것을 요구
    // 주의 => gc()를 호출한다고 해서 바로 가비지 컬렉터가 동작하는 것은 아니다.
    // => 가비지 컬렉터의 실행을 앞당겨달라고 요청하는 것이다.
    // => 그 요구를 수용할 지 여부는 JVM의 판단에 달려있다.
    // => 따라서 gc()를 호출하면 가비지 컬렉터가 바로 실행된다고 믿지말라!
    
  }
}
