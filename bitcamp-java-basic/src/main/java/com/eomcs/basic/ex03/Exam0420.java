package com.eomcs.basic.ex03;

public class Exam0420 {
  public static void main(String[] args) {
    System.out.println(65);
    
    System.out.println((char)65);
    
    System.out.println((char)0x41);
    
    System.out.println((char)0xAC00);
    
    System.out.println((char)(0xAC00 + 1));
    
    for (int i = 0; i < 26; i++) {
      System.out.println((char) (i + 65) + ",");
    }
    
    // EUC-KR (2바이트 : 한글 2560자 + 한자 포함)
    // - 국제 표준 한글 문자 집합
    // - 한글 음절 한 개에 대해 인코딩 규칙을 정의한 완성형 인코딩 규칙이다.
    // - 현재 유통되는 모든 한글 음절을 표현할 수 없다.
    // - ex) 똠
    
    // 조합형 (2바이트 : 한글(1) 초성(5비트) 중성(5비트) 종성(5비트))
    // - 국제 표준이 아니다.
    
    // MS949(=CP949: 2바이트)
    // - 윈도우 OS의 인코딩 규칙이다.
    // - EUC-KR + 현재 유통되는 한글 음절 추가
    // MS949에 추가도니 문자 : 똠(0x8c63), 똡(0x8c64) 등
    // 기존의 EUC-KR에 문자 코드를 추가했기 때문에 정렬할 떄 문제 발생
    
    // Unicode
    // - 국제 표준 인코딩 규칙
    // - UCS-2의 경우 영어, 한글 모두 2바이트로 인코딩한다.
    // - MS949의 모든 한글 문자가 포함되어있다.
    // 기존의 EUC-KR과 MS949와 호환이 되지 않는다.
    // JVM은 내부에서 문자열을 다룰 때 UCS-2를 사용한다.
    // 즉 영어, 한글 모두 2바이트 유니코드로 다룬다.
    
    // UTF-8(1~4바이트)
    // 기존 영어권 시스템에서 유니코드 문자를 사용하기 위해 탄생
    // 기존 시스템은 ISO-8859-1 규칙에 따라 영어를 1 바이트로 다룬다.
    // 그러나 유니코드는 영어를 2바이트로 다룬다.
    // 유니코드를 사용하려면 영어를 2바이트로 다뤄야하기 때무넹 기존 시스템을 모두 변경해야한다.
    // 따라서 기존 시스템을 변경하지 않고 유니코드를 사용할 수 있도록 UTF-8을 만들었다.
    
    // 
  }

}
